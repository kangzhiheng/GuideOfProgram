//-----------------------------------------------------------------------------
// 文 件 名: 15_二进制中的1的个数.cpp
// 作    者：adoredee
// 创建时间：2019.05.07
// 描    述：二进制中的1的个数
// 版    本：
//-----------------------------------------------------------------------------
// Copyright (C) 2019 Shanghai Jiao Tong University
//-----------------------------------------------------------------------------

// 面试题15：二进制中1的个数
// 题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如
//      把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。

/* 方法一：常规操作
   原操作数不动，先取1，然后不断左移1，与原数各个二进制位数相与，比如
   原数为9，二进制表示为 1001，则
       第一次运算：   1001
	                0001
				  --------
				    0001
	   第二次运算：左移0001
	                1001
					0010
				  --------
				    0000
	   依此类推，原数二进制位数有几位，则移几次
*/
#include <iostream>

using namespace std;

int NumOf_1_inBinary_Normal(int value)
{
	int counts = 0;
	size_t flag = 1;

	while (flag)
	{
		if (value & flag)
			counts++;
		flag = flag << 1;
	}

	return counts;
}

/* 方法二：巧妙操作
   只针对原数字中的1操作。
   把一个整数减去1，再与原数做与运算，会把原数中最右边的1变成0.则原数中有多少个1，就进行多少次操作。
   1. 原数最右边是1，比如1001，减去1为1000，1001与1000相与得1000，即最右边的1变成了0，再减去1，为第二种情况；
   2. 原数最右边是0，比如1010，减去1为1001，即这个二进制数中最右边首先出现1的那一位变成0，之前保持不变，之后的0变为1，
      1010 & 1001 = 1000
   距离：
   9，二进制为1001，因为9不为0，1个数至少为1，
   第一次减1，1001 & 1000 = 1000，1的个数加1，此时为2.
   第二次减1，1000 & 0111 = 0000，结束
*/
int NumOf_1_inBinary_Wonderful(int value)
{
	int counts = 0;

	while (value)
	{
		++counts;    // 如果value不为0，则这个数里至少有一个1
		value = (value - 1) & value;
	}

	return counts;
}

int main()
{
	cout << "请输入一个数: ";
	int value;
	cin >> value;

	cout << value << "的二进制中的1的个数为(常规操作)―>" << NumOf_1_inBinary_Normal(value) << endl;
	cout << value << "的二进制中的1的个数为(巧妙操作)―>" << NumOf_1_inBinary_Wonderful(value) << endl;

	return 0;
}